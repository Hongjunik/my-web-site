<!DOCTYPE html>
<html lang="en">  <!-- 기본언어 : 영어 -->
<head>
  <meta charset="UTF-8" /> <!-- 페이지 언어 인코딩 형식 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/> <!-- 화면크기에 따라 보여지는 크기 맞추기 -->
  <title>Web Animation(canvas_js_css)[1단원-7]</title>
  <style>
    /* 페이지 전체 설정 */
    body {
      margin: 0;
      padding: 0;
      text-align: center;
      font-family: sans-serif;
    }
    /* 애니메이션 화면 설정 */
    #canvas {
      background: #DCD7C9;
      display: block;
      margin: 0 auto;
    }

    /* 1_5 : PC 안내 문구 기본은 숨김 */
    .pc-guide {
      display: none; /* 1_5 : 화면에 보이지 않게함 */
      margin-top: 10px; /* 1_5 : 위쪽여백 */
      font-size: 16px; /* 1_5 : 버튼 글자크기 */
      color: #333; /* 1_5 : 글자색 */
      font-weight: bold; /* 1_5 : 글자굵게 */
    }

    /* PC에서는 600x600 고정 */
    @media (min-width: 769px) {
      #canvas {
      width: 600px;
      height: 600px;
      }

      .pc-guide {
        display: block; /* 1_5 : pc-guide를 PC에서 접속시 보이게함 */
      }
    }

    /* 1_5 : 버튼을 감싸는 div 숨기기 (PC에서는 안 보이게하고 스마트폰에서 접속이 보임) */
    .controls {
      display: none; /* 1_5 : 화면에 보이지 않게함 */
      margin-top: 10px;
      flex-direction: column;
      align-items: center;
    }

    .controls .row {
      display: flex;
      justify-content: center;
    }

    /* 1_5 : 스마트폰에서 보여질 버튼 모양 설정 */
    .controls button {
      font-size: 24px;
      padding: 15px 20px;
      margin: 5px;
      min-width: 60px;
      border-radius: 10px;
      border: none;
      background-color: #333;
      color: white;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }

    .controls button:active {
      background-color: #555;
    }

    /* 1_5 : 화면이 작을 때 (스마트폰 등에서 보인다면 아래 코드동작)
       화면의 폭이 최대 768픽셀보다 이하이면 아래 css동작함 아니면 위 PC용 CSS @media (min-width: 769px) 동작함
       최근 스마트폰의 해상도는 PC보다도 좋은 경우가 많은데 768픽셀보다 작으면 스마트폰이라니?
        이유 : 스마트폰의 물리적인 해상도는 더 크지만, 화면을 작게 보이도록 하기 위해 **디바이스 픽셀 비율(DPR, divicePixelRatio)**을 사용함
       아이폰13의 가로해상도가 1170픽셀인데 CSS픽셀로는 1170/3=390픽셀임
       현재 기기로 보아도 768 CSS픽셀이면 모든 스마트폰에서 접속하는 것으로 판단함 */

    @media (max-width: 768px) {
      #canvas {
        width: 100vw; /* 1_5 : 스마트폰 화면 canvas 가로 전체 크기로함 */
        height: 100vw; /* 1_5 : 화면 canvas 세로 = 가로 (정사각형) */
      }
      .controls {
        display: block; /* 1_5 : 스마트폰에서 접속시 controls을 보이게함 */
      }
      .pc-guide {
        display: none; /* 1_5 : pc-guide를 스마트폰 접속시 숨김 */
      }
    }

    /* === OverLay_UI === */
    .overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      justify-content: center;
      align-items: center;
    }

    .overlay-content {
      background: white;
      padding: 30px;
      border-radius: 10px;
      text-align: center;
      min-width: 250px;
    }

    .overlay-content h2 { margin-bottom: 20px;}
    .overlay-content button {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
    }

  </style>
</head>
<body>
  <!-- 애니메이션 화면 만들기 -->
  <canvas id="canvas"></canvas>

  <!-- 1_5 : 애니메이션 화면 만들기 : 스마트폰에서 접속 할 때만 controls이 보이게됨 -->
  <div class="controls">
    <div class="row">
      <button id="upBtn">↑</button>
    </div>
    <div class="row">
      <button id="leftBtn">←</button>
      <button id="downBtn">↓</button>
      <button id="rightBtn">→</button>
    </div>
  </div>

  <!-- 1_5 : PC 전용 안내 문구 -->
  <div class="pc-guide">
    PC에서 접속했습니다. 방향키로 이동하세요.<br>
    스마트폰에서 접속 시 보이는 버튼으로 이동하세요.
  </div>

  <!-- OverLay_UI -->
   <div class="overlay" id="overlay">
    <div class="overlay-content">
      <h2 id="overlayTitle">Game Over</h2>
      <p id="overlayMessage"></p>
      <button id="restartBtn">재시작</button>
    </div>
   </div>

  <script>
    // 캔버스 요소 J5 변수만들기
    const drawingBoard = document.getElementById('canvas');
    // 캔버스에 2D그림을 그리는 도구 변수만들기
    const drawingPen = drawingBoard.getContext('2d');

    // 캔버스 크기를 CSS와 맞춰줌 (중요!)
    // 아래처럼 하면 PC는 600x600으로 설정되고 스마트폰은 360x360으로 화면계산된 나중에 필요하면 참고사용
    // drawingBoard.width = drawingBoard.clientWidth;
    // drawingBoard.height = drawingBoard.clientHeight;
    // 캔버스 내부 해상도는 무조건 600x600 고정(PC, 스마트폰 모두)
    drawingBoard.width = 600;
    drawingBoard.height = 600;

    // 주인공 위치(화면 왼쪽 하단)
    let x = 20;
    let y = (drawingBoard.height - 30); //570

    //적 위치(하면 가운데)
    let ex = new Array(10);
    let ey = new Array(10);

    let enemyCnt=ex.length;

    

    let timerMinutes = 0;
    let timerSeconds = 0;
    let timerCenti = 0; //  1/100초
    let startTime = Date.now();
    let stopCountdown = null;
    let isGameOver = false;

   function startCountdown(ms, onTick, onEnd) {
    const start=performance.now();
    const end=start+ms;
    let tId=0;

    function step() {
      const now = performance.now();
      const remaining = Math.max(0, end - now); //reamining에 0과 end-now중 큰 값을 넣는다.(음수가 변수에 들어가는 경우를 없에서 보정을 함)
      
      const totalCenti = Math.floor(remaining / 10); // 1/100초 단위
      const minutes = Math.floor(totalCenti / 6000); // 60*100
      const seconds = Math.floor((totalCenti % 6000) / 100);
      const centi = totalCenti % 100;

      onTick?.(minutes, seconds, centi);

      if (remaining <= 0) {
        onEnd?.();
        return;
      }
      tId = setTimeout(step, 10);
    }

    step();
    return () => clearInterval(tId);
   }

    //주인공 크기
    const heroWidth = 10;
    const heroHeith = 10;

    //적 크기
    const enemyWidth = 20;
    const enemyHeith = 20;

    // 주인공 이동속도
    const moveAmount = 5;

    // 주인공 이동함수
    function moveRight() {x = x + moveAmount;}
    function moveLeft() {x = x - moveAmount;}
    function moveDown() {y = y + moveAmount;}
    function moveUp() {y = y - moveAmount;}

    // 1_4 : 주인공 이동제한
    function move_limit() {
      if(x<0) {//왼쪽 이동제한
        x = 0;
      }
      if(x>=drawingBoard.width-10) {//오른쪽 이동제한
        x = (drawingBoard.width-10);
      }
      if(y<0) {//위쪽 이동제한
        y=0;
      }
      if(y>=drawingBoard.height-10) {//아래쪽 이동제한
        y=(drawingBoard.height-10);
      }
    }

    //1_4 : 캔버스 왼쪽 상단에 텍스트 출력함수
    function drawCoordinate() {
      drawingPen.fillStyle = 'black';
      drawingPen.font = '10px sans-serf';
      drawingPen.fillText(`x: ${x} y: ${y}`, 10, 20);
    }

    // 주인공 출력함수
    function drawHero() {
      drawingPen.fillStyle = 'black';
      drawingPen.fillRect(x, y, heroWidth, heroHeith);
    }

    function arrayCheck() {


      /*let tempX, tempY;
      for (let i = 0; i < ex.length; i++) {
        tempX = Math.round(Math.random() * (drawingBoard.width - 20));
        tempY = Math.round(Math.random() * (drawingBoard.height - 20));
        if (tempX != ex[i] || tempY != ey[i]) {
          ex[i] = tempX;
          ey[i] = tempY;
        }else {
          continue;
        }
      }*/
    }

    // 적 출력함수
    function enemy1() {
      for (let i = 0; i < ex.length; i++) {
        drawingPen.fillStyle = 'red';
        drawingPen.fillRect(ex[i], ey[i], enemyWidth, enemyHeith);
      }
    }

    // 적 충돌함수
    function collision1() {
      for (let i = 0; i < ex.length; i++) {
        if((x+heroWidth) > ex[i] && x < (ex[i]+enemyWidth) && (y+heroHeith) > ey[i] && y < (ey[i]+enemyHeith)) {
          ex[i] = Number.MAX_SAFE_INTEGER;
          ey[i] = Number.MAX_SAFE_INTEGER;
          enemyCnt--;
        }
      }
      
    }

    function counter() {
        drawingPen.fillStyle = 'black';
        drawingPen.font = '10px sans-serf';
        drawingPen.fillText(`RED no ${enemyCnt}`, 550, 20);
    }

    function drawTimer() {
      drawingPen.fillStyle = 'black';
      drawingPen.font = '20px sans-serf';
      drawingPen.fillText(`${timerMinutes}:${timerSeconds.toString().padStart(2,"0")}:${timerCenti.toString().padStart(2,"0")}`,
        (canvas.width/2)-40, 20
      );
    }

    const keys = {
      ArrowLeft: false,
      ArrowRight: false,
      ArrowUp: false,
      ArrowDown: false
    }

    document.addEventListener('keydown', (e) => {
      if (keys.hasOwnProperty(e.key)) {
        keys[e.key] = true;
      }
    });

    document.addEventListener('keyup', (e) => {
      if(keys.hasOwnProperty(e.key)) {
        keys[e.key] = false;
      }
    });

    // === OverLay 관련 ===
    const overlay = document.getElementById("overlay");
    const overlayTitle = document.getElementById("overlayTitle");
    const overlayMessage = document.getElementById("overlayMessage");
    const restartBtn = document.getElementById("restartBtn");
    restartBtn.addEventListener("click", () => location.reload());

    function gameOverOverlay(type, value = "") {
      if (type === "over") {
        overlayTitle.textContent = "게임오버";
        overlayMessage.textContent = "시간이 다 되었습니다!";
      }else if (type === "record") {
        overlayTitle.textContent = "🎉 클리어!";
        overlayMessage.textContent = `기록: ${value}초`;
      }
      overlay.style.display = "flex";
    }

    

    // 화면에 출력하기
    function draw() {
      if (isGameOver) return; // 게임 끝났으면 draw 루프 중단

      drawingPen.fillText(`x: ${x} y: ${y}`, 10, 20); //1_4 : 캔버스 왼쪽 상단에 텍스트 출력
      drawingPen.clearRect(0, 0, canvas.width, canvas.height);  //화면지우기/      drawTimer();  // 타이머출력함수호출
      drawHero(); // 주인공출력함수호출
      enemy1(); // 적 출력함수 호출
      collision1(); //적 충돌함수 호출
      counter();  // 적 카운트함수 호출
      move_limit(); //1_4 : 주인공 이동 제한 함수호출
      drawCoordinate(); //1_4 : 텍스트 출력 함수호출
      drawTimer();  //타이머 출력함수 호출

      if (keys.ArrowLeft) moveLeft();
      if (keys.ArrowRight) moveRight();
      if (keys.ArrowUp) moveUp();
      if (keys.ArrowDown) moveDown();

      // 조건 체크
      if (enemyCnt === 0 && !isGameOver) {
        let elapsed = ((Date.now() - startTime)/1000).toFixed(2);
        stopCountdown?.();
        isGameOver = true;
        gameOverOverlay("record", elapsed);
      }
    }

    stopCountdown = startCountdown(
      60_000,
      (m, s, c) => { timerMinutes = m; timerSeconds = s; timerCenti = c; },
      () => { 
        if (!isGameOver) {              // 이미 게임 끝났으면 다시 안 띄움
          isGameOver = true;
          gameOverOverlay("over"); 
        }
      }
    );

    setInterval(draw, 16);  // 60FPS
    
    const setBtnHod = (key, isDown) => {
      keys[key] = isDown;
    };

    const bindButton = (id, key) => {
      const btn = document.getElementById(id);
      btn.addEventListener('touchstart', () => setBtnHod(key, true));
      btn.addEventListener('touchend', () => setBtnHod(key, false));
      btn.addEventListener('mousedown', () => setBtnHod(key, true));
      btn.addEventListener('mouseup', () => setBtnHod(key, false));
      btn.addEventListener('mouseleave', () => setBtnHod(key, false));
    };

    bindButton("leftBtn", "ArrowLeft");
    bindButton("rightBtn", "ArrowRight");
    bindButton("upBtn", "ArrowUp");
    bindButton("downBtn", "ArrowDown");
 </script>

</body>
</html>
